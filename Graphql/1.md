GraphQL - Is a query language for API'S 
Enabled declarative data fetching
Single endpoint

GraphGL is the better Rest
More flexibility and efficiency in client-server communication
No more over and underFetching

Defining simple types (SDL)

type Person {
    name: String!
    age: Int!
    posts: [Post!]!
}

type Post {
    title: String!
    author: Person!
}

one to many 

Fetching data with Queries

{
    allPersons {
        name
    }
}

{
    allPersons(last:2) {
        name
        age
            posts {
                title
            }
    }
}

Writing Data with mutations

mutation {
    createperson(name: "Bob", age: 36){
        name
        age
    }
}

Realtime Updates with Subscriptions

subscription {
    newPerson {
        name
        age
    }
}

The GraphQL Schema

Defines capabilites of the API by specifyin how clintes fetch and update data

Root Types

type Query, Mutation and Subscription

type Query {
    allPersons(last: Int): [Person!]!
    allPosts(last: Int): [Post!]!
}

type Mutation {
    createPerson(name: String!, age: String!): Person!
    updatePerson(id: ID!, name: String!, age: String!)
    deletePerson(id: ID!)
    createPost(Title: String!): Post!
}

type subscription {
    newPerson: Person!
    updatedPerson: Person!
    etc
}


--Big Picture (Architecture)--

Is only a specification

1. GraphQl server with a connected databse
2. GraphQL server to integrat existing system
3. A hybrid approach with a connected database and integration of existing system.

Case 1 - Most common, single web that implements graphQL.

Fragment is a collection of fields on a specific type, like a interface can be extend

fragment addressDetails on User {
  name
  street
  zipcode
  city
}

The same field but different arguments. 

Scalar Types = String, Int, Float, Boolean and ID
Objects = Example User and Post

enum Weekday {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

An interface can be used to describe a type in an abstract way. It allows you to specify a set of fields that any concrete type, which implements this interface, needs to have. Interface must have a ID.

type Adult {
  name: String!
  work: String!
}

type Child {
  name: String!
  school: String!
}

union Person = Adult | Child